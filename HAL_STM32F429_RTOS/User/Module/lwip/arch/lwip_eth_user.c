#include "./lwip_eth_user.h"

#include "main.h"
#include "sys_arch.h"
#include "lwip/opt.h"

#include "lwip/sys.h"
#include "lwip/api.h"

#include "lwip/sockets.h"

#include "lwip/apps/fs.h"


//static void Netconn_TCP_Client(void *thread_param)
//{
//    struct netconn *conn;
//    int ret;
//    ip4_addr_t ipaddr;
//    uint8_t send_buf[] = "This is a TCP Client test...\n";

//    while(1)
//    {
//        conn = netconn_new(NETCONN_TCP);    /* 申请一个TCP连接数据结构 */

//        if(conn == NULL)
//        {
//            printf("create conn failed!\n");
//            vTaskDelay(10);
//            continue;
//        }

//        IP4_ADDR(&ipaddr,IP_ADDR0,IP_ADDR1,IP_ADDR2,IP_ADDR3);    /* 配置服务器IP地址 ipaddr */

//        ret = netconn_connect(conn, &ipaddr, LOCAL_PORT); /* 连接服务器,TCP进行握手，指定端口5001 */

//        if(ret == -1)
//        {
//            printf("Connect fail!\n");
//            netconn_close(conn);          /* 连接失败，关闭连接 */
//            vTaskDelay(10);
//            continue;
//        }

//        printf("Connect to iperf server successful!\n");

//        while(1)
//        {
//            /* 连接成功，每隔一秒发送测试数据 */
//            ret = netconn_write(conn, send_buf, sizeof(send_buf),0);
//            vTaskDelay(1000);
//        }
//    }

//}


//void Netconn_TCP_Client_Init(void)
//{
//    sys_thread_new("Netconn_TCP_Client", Netconn_TCP_Client, NULL, 512, 4);
//}




//static void Netconn_TCP_Server_thread(void *arg)
//{
//    struct netconn *conn, *newconn;
//    err_t err;
//    LWIP_UNUSED_ARG(arg);

//    conn = netconn_new(NETCONN_TCP);    /* 申请一个TCP连接数据结构 */
//    netconn_bind(conn, IP_ADDR_ANY, LOCAL_PORT);  /* 绑定本地IP地址和端口号 */

//    LWIP_ERROR("tcpecho: invalid conn", (conn != NULL),return;);

//    netconn_listen(conn);               /* 进入监听状态 */

//    while(1)
//    {
//        err = netconn_accept(conn, &newconn);   /* 处理客户端连接请求，阻塞 */

//        /* 是否有客户端连接进来 */
//        if(err == ERR_OK)   
//        {
//            struct netbuf *buf;
//            void *data;
//            u16_t len;

//            /* 接收客户端发来的数据包 */
//            while( (err = netconn_recv(newconn, &buf)) == ERR_OK)
//            {
//                do
//                {
//                    netbuf_data(buf, &data, &len);                          /* 保存数据 */
//                    err = netconn_write(newconn, data, len, NETCONN_COPY);  /* 回写给客户端 */
//#if 0
//                    if(err != ERR_OK)
//                    {
//                        printf("tcpecho: netconn_write: error \"%s"\n",lwip_strerr(err));
//                    }
//#endif
//                }while(netbuf_next(buf) >= 0);  /* 等待数据回写完成 */

//                netbuf_delete(buf);
//            }

//            netconn_close(newconn);             /* 关闭与客户端的连接 */
//            netconn_delete(newconn);
//        }
//    }
//}


//void Netconn_TCP_Server_Init(void)
//{
//    sys_thread_new("Netconn_TCP_Server_thread", tcpecho_thread, NULL, 512, 4);
//}


//static void Netconn_UDP_Server_thread(void *arg)
//{
//    struct netconn *conn;
//    struct netbuf *buf;
//    char buffer[4096];
//    err_t err;
//    LWIP_UNUSED_ARG(arg);

//    conn = netconn_new(NETCONN_UDP);          /* 创建一个UDP连接数据结构 */
//    netconn_bind(conn, IP_ADDR_ANY, LOCAL_PORT);    /* 绑定本地IP和端口号 */

//    LWIP_ERROR("udpecho: invalid conn", (conn != NULL), return;);

//    while(1)
//    {
//        err = netconn_recv(conn, &buf);   /* 线程阻塞中接收数据，有数据则存入buf中 */

//        if(err == ERR_OK)
//        {
//            if(netbuf_copy(buf, buffer, sizeof(buffer)) != buf->p->tot_len)
//            {
//                LWIP_DEBUGF(LWIP_DBG_ON, ("netbuf_copy failed\n"));
//            }
//            else
//            {
//                buffer[buf->p->tot_len] = '\0';
//                err = netconn_send(conn, buf);    /* 回显收到的数据 */

//                if(err != ERR_OK)
//                {
//                    LWIP_DEBUGF(LWIP_DBG_ON, ("netconn_send failed: %d\n",(int)err));
//                }
//                else
//                {
//                    LWIP_DEBUGF(LWIP_DBG_ON, ("got %s\n",buffer));
//                }
//            }
//            netbuf_delete(buf);
//        }
//    }
//}

//void Netconn_UDP_Server_Init(void)
//{
//    sys_thread_new("udpecho_thread", Netconn_UDP_Server_thread, NULL, 2048, 4);
//}


//static void Socket_TCP_Client_thread(void *thread_param)
//{
//#if 0    
//    int sock = -1;
//    struct sockaddr_in client_addr;   /* 定义socket地址信息结构体 */

//    uint8_t send_buf[] = "This is a TCP Client test...\n";

//    while(1)
//    {
//        sock = socket(AF_INET, SOCK_STREAM, 0);   /* 申请一个socket数据结构,STREAM,流，*/

//        if(sock < 0)
//        {
//            printf("Socket error\n");
//            vTaskDelay(10);
//            continue;
//        }

    //    client_addr.sin_family = AF_INET;     /* 配置协议簇，对于TCP/IP协议，始终是这个常量 */
//        client_addr.sin_port = htons(LOCAL_PORT);   /* 端口信息 */
//        client_addr.sin_addr.s_addr = inet_addr(DEST_IP_ADDR);/* IP地址 */
//        memset(&(client_addr.sin_zero), 0, sizeof(client_addr.sin_zero)); /* sin_zero字段未用到，配置为0 */

            /* 发起TCP握手连接 */
//        if(connect(sock,(struct sockaddr *)&client_addr,sizeof(struct sockaddr)) == -1)
//        {
//            printf("Connect failed!\n");
//            closesocket(sock);
//            vTaskDelay(10);
//            continue;
//        }

//        printf("Connect to iperf server successful!\n");

//        while(1)
//        {
                /* 发送数据 */
//            if(write(sock, send_buf, sizeof(send_buf)) < 0)
//            {
//                break;
//            }

//            vTaskDelay(1000);
//        }

//        closesocket(sock);
//    }
//#endif
//}


//void Socket_TCP_Client_Init(void)
//{
//    sys_thread_new("client", Socket_TCP_Client_thread, NULL, 512, 4);
//}


static void Socket_TCP_Server_Thread(void *arg)
{
    int sock = -1,connected;
    char *recv_data;
    struct sockaddr_in server_addr, client_addr;
    socklen_t sin_size;
    int recv_data_len;

    /* 发配空间 */
    recv_data = (char *)pvPortMalloc(RECV_DATA);

    if(recv_data == NULL)
    {
        printf("No memory\n");
        goto __exit;
    }

    /* 申请一个socket数据结构 */
    sock = socket(AF_INET, SOCK_STREAM, 0);

    if(sock < 0)
    {
        printf("Socket error\n");
        goto __exit;
    }

    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(LOCAL_PORT);
    memset(&(server_addr.sin_zero), 0, sizeof(server_addr.sin_zero));

    /* 绑定本地端口信息 */
    if(bind(sock, (struct sockaddr *)&server_addr, sizeof(struct sockaddr)) == -1)
    {
        printf("Unable to bind\n");
        goto __exit;
    }

    if(listen(sock, 5) == -1)
    {
        printf("Listen error\n");
        goto __exit;
    }

    while(1)
    {
        sin_size = sizeof(struct sockaddr_in);

        /* 等待连接请求 */
        connected = accept(sock, (struct sockaddr *)&client_addr, &sin_size);

        printf("new client connected from (%s, %d)\n",

        /* 将IP,端口数据转10进制 */
        inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));
        {
            int flag = 1;

            setsockopt(connected,IPPROTO_TCP,TCP_NODELAY,(void *) &flag,sizeof(int)); 
        }

        while (1)
        {
            recv_data_len = recv(connected, recv_data, RECV_DATA, 0);

            if (recv_data_len <= 0)
            {

                break;
            }

            printf("recv %d len data\n",recv_data_len);
            write(connected,recv_data,recv_data_len);

        }

        if (connected >= 0)
        {
            closesocket(connected);
        }

        connected = -1;
    }

__exit:
    if (sock >= 0) 
    {
        closesocket(sock);
    }

    if (recv_data) 
    {
        free(recv_data);
    }
}

void Socket_TCP_Server_Init(void)
{
    sys_thread_new("Socket_TCP_Server_Thread", Socket_TCP_Server_Thread, NULL, 512, 4);
}




#define IP_ADDR        "114.215.151.106"

#ifdef    LWIP_DNS
#define   HOST_NAME       "embedfire.com"     
#else
#define   HOST_NAME       "114.215.151.106"     
#endif

uint32_t *pSDRAM= (uint32_t*)SDRAM_BANK_ADDR;

uint8_t get_buf[]= "GET / HTTP/1.1\r\nHost: embedfire.com\r\n\r\n\r\n\r\n";

static void Http_Client(void *thread_param)
{

    int sock = -1,rece;
    struct sockaddr_in client_addr;

    uint8_t *pbufdata = pvPortMalloc(5000);  
    
    char* host_ip;
  
#ifdef  LWIP_DNS
    ip4_addr_t dns_ip;
    netconn_gethostbyname(HOST_NAME, &dns_ip);
    host_ip = ip_ntoa(&dns_ip);
    printf("host name : %s , host_ip : %s\n",HOST_NAME,host_ip);
#else
    host_ip = HOST_NAME;
#endif  
    
    printf("目标端口号是：%d\n\n",DEST_PORT);
    
    while(1)
    {
        sock = socket(AF_INET, SOCK_STREAM, 0);

        if (sock < 0)
        {
            printf("Socket error\n");
            vTaskDelay(10);
            continue;
        } 

        client_addr.sin_family = AF_INET;      
        client_addr.sin_port = htons(DEST_PORT);   
        client_addr.sin_addr.s_addr = inet_addr(host_ip);
        memset(&(client_addr.sin_zero), 0, sizeof(client_addr.sin_zero));    

        if (connect(sock, (struct sockaddr *)&client_addr, sizeof(struct sockaddr)) == -1) 
        {
            printf("Connect failed!\n");
            closesocket(sock);
            vTaskDelay(10);
            continue;
        }                                           
    
        printf("Connect to server successful!\n");
        memset(pSDRAM,0,400000);
        printf("\n************************************************************\n");
        write(sock,get_buf,sizeof(get_buf));

    while (1)
    {
//      if(write(sock,get_buf,sizeof(get_buf)) < 0)
//        break;

      rece = recv(sock, (uint8_t*)pSDRAM, 400000, 0);
      if (rece <= 0) 
        break;

      printf("%s\n",(uint8_t*)pSDRAM);

    }

    printf("\n**********************************************************\n");
    
    memset(pSDRAM,0,400000);
    closesocket(sock);
    vTaskDelay(10000);
  }

}

void Htts_Client_init(void)
{
    sys_thread_new("client", Http_Client, NULL, 2048, 4);
}





#ifndef HTTPD_DEBUG
#define HTTPD_DEBUG     LWIP_DBG_OFF
#endif

static const char http_html_hdr[] = "HTTP/1.1 200 OK\r\nContent-type: text/html\r\n\r\n";
static const char http_index_html[] = 
"<html><head><title>蔡楚强史上最帅!</title></head>\
                                       <body><h1 align=\"center\">Hello World!</h1>\
                                       <h2 align=\"center\">Welcome to Fire LwIP HTTP Server!</h1>\
                                       <p align=\"center\">This is a small test page, served by httpserver-netconn.</p>\
                                       <p align=\"center\"><a href=\"http://www.firebbs.cn/forum.php/\"> <font size=\"6\"> 野火电子论坛 </font> </a></p>\
                                       <a href=\"http://www.firebbs.cn/forum.php/\">\
                                       <p align=\"center\"><img src=\"https://dingyue.nosdn.127.net/e8YpYXEBx37XL1=xTnVuaQLuoVqKH21rN6OvwXVZkP0tj1528602866444compressflag.png\" /></a>\
                                       </body></html>";



static void http_server_netconn_serve(struct netconn *conn)
{
    struct netbuf *inbuf;
    char *buf;
    u16_t buflen;
    err_t err;

    /* 读取数据 */
    err = netconn_recv(conn, &inbuf);

    if(err == ERR_OK)
    {
        /* 将inbuf的数据写入buf中 */
        netbuf_data(inbuf, (void **)&buf, &buflen);

        /* 判断GET命令,标志C库strstr？ */
        if(buflen >= 5 && buf[0] == 'G' && 
                          buf[1] == 'E' && 
                          buf[2] == 'T' && 
                          buf[3] == ' ' && 
                          buf[4] == '/' )
        {
            /* 发送数据头 */
            netconn_write(conn, http_html_hdr, sizeof(http_html_hdr) - 1,NETCONN_NOCOPY);

            /* 发送网页数据 */
            netconn_write(conn, http_index_html,sizeof(http_index_html) - 1, NETCONN_NOCOPY);
        }
    }
    netconn_close(conn);    /* 关闭连接 */

    /* 释放 inbuf */
    netbuf_delete(inbuf);
}

static void http_server_netconn_thread(void *arg)
{
    struct netconn *conn, *newconn;
    err_t err;
    LWIP_UNUSED_ARG(arg);

    conn = netconn_new(NETCONN_TCP);        /* 创建netconn连接结构 */
    netconn_bind(conn, IP_ADDR_ANY, 80);    /* 绑定端口号与IP地址，端口号默认是80 */
    LWIP_ERROR("http_server: invalid conn", (conn != NULL), return;);

    /* 监听 */
    netconn_listen(conn);

    do
    {
        /* 处理连接请求 */
        err = netconn_accept(conn, &newconn);

        if(err == ERR_OK)
        {
            /* 发送网页数据 */
            http_server_netconn_serve(newconn);

            /* 删除连接结构 */
            netconn_delete(newconn);
        }

    } while (err == ERR_OK);

    /* 关闭 */
    netconn_close(conn);
    
    netconn_delete(conn);
    
}

void http_server_netconn_init(void)
{


    /* 创建线程 */
    sys_thread_new("http_server_netconn", http_server_netconn_thread, NULL, 2048, 4);
}









static void Http_Server_Socket(struct netconn *conn)
{
    struct netbuf *inbuf;
    char *buf;
    u16_t buflen;
    err_t err;

    /* 读取数据 */
    err = netconn_recv(conn, &inbuf);

    if(err == ERR_OK)
    {
        /* 将inbuf的数据写入buf中 */
        netbuf_data(inbuf, (void **)&buf, &buflen);

        /* 判断GET命令,标志C库strstr？ */
        if(buflen >= 5 && buf[0] == 'G' && 
                          buf[1] == 'E' && 
                          buf[2] == 'T' && 
                          buf[3] == ' ' && 
                          buf[4] == '/' )
        {
            /* 发送数据头 */
            netconn_write(conn, http_html_hdr, sizeof(http_html_hdr) - 1,NETCONN_NOCOPY);

            /* 发送网页数据 */
            netconn_write(conn, http_index_html,
            sizeof(http_index_html) - 1, NETCONN_NOCOPY);
        }
    }
    netconn_close(conn);    /* 关闭连接 */

    /* 释放 inbuf */
    netbuf_delete(inbuf);
}


static void Http_Server_Socket_thread(void *arg)
{
    int sock = -1,connected;
    char *recv_data;
    struct sockaddr_in server_addr, client_addr;
    socklen_t sin_size;
    int recv_data_len;

    /* 发配空间 */
    recv_data = (char *)pvPortMalloc(RECV_DATA);

    if(recv_data == NULL)
    {
        printf("No memory\n");
        goto __exit;
    }

    /* 申请一个socket数据结构 */
    sock = socket(AF_INET, SOCK_STREAM, 0);

    if(sock < 0)
    {
        printf("Socket error\n");
        goto __exit;
    }

    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(LOCAL_PORT);
    memset(&(server_addr.sin_zero), 0, sizeof(server_addr.sin_zero));

    /* 绑定本地端口信息 */
    if(bind(sock, (struct sockaddr *)&server_addr, sizeof(struct sockaddr)) == -1)
    {
        printf("Unable to bind\n");
        goto __exit;
    }

    /* 侦听信息 */
    if(listen(sock, 5) == -1)
    {
        printf("Listen error\n");
        goto __exit;
    }

    sin_size = sizeof(struct sockaddr_in);

//    do
//    {

//        /* 等待连接请求 */
//        connected = accept(sock, (struct sockaddr *)&client_addr, &sin_size);


//    } while ();
    

    while(1)
    {


        while (1)
        {

            //Http_Server_Socket();

        }

        if (connected >= 0)
        {
            closesocket(connected);
        }

        connected = -1;
    }

__exit:
    if (sock >= 0) 
    {
        closesocket(sock);
    }

    if (recv_data) 
    {
        free(recv_data);
    }
    
}

void Http_Server_Socket_Init(void)
{

    /* 创建线程 */
    sys_thread_new("Http_Server_Socket_thread", Http_Server_Socket_thread, NULL, 2048, 4);
}
















/* Private typedef -----------------------------------------------------------*/
/* Private define ------------------------------------------------------------*/
#define WEBSERVER_THREAD_PRIO    ( osPriorityAboveNormal )

/* Private macro -------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/
u32_t nPageHits = 0;
portCHAR PAGE_BODY[512];

/* Format of dynamic web page: the page header */
static const unsigned char PAGE_START[] = {
0x3c,0x21,0x44,0x4f,0x43,0x54,0x59,0x50,0x45,0x20,0x68,0x74,0x6d,0x6c,0x20,0x50,
0x55,0x42,0x4c,0x49,0x43,0x20,0x22,0x2d,0x2f,0x2f,0x57,0x33,0x43,0x2f,0x2f,0x44,
0x54,0x44,0x20,0x48,0x54,0x4d,0x4c,0x20,0x34,0x2e,0x30,0x31,0x2f,0x2f,0x45,0x4e,
0x22,0x20,0x22,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x77,0x77,0x77,0x2e,0x77,0x33,
0x2e,0x6f,0x72,0x67,0x2f,0x54,0x52,0x2f,0x68,0x74,0x6d,0x6c,0x34,0x2f,0x73,0x74,
0x72,0x69,0x63,0x74,0x2e,0x64,0x74,0x64,0x22,0x3e,0x0d,0x0a,0x3c,0x68,0x74,0x6d,
0x6c,0x3e,0x0d,0x0a,0x3c,0x68,0x65,0x61,0x64,0x3e,0x0d,0x0a,0x20,0x20,0x3c,0x74,
0x69,0x74,0x6c,0x65,0x3e,0x53,0x54,0x4d,0x33,0x32,0x46,0x34,0x78,0x78,0x54,0x41,
0x53,0x4b,0x53,0x3c,0x2f,0x74,0x69,0x74,0x6c,0x65,0x3e,0x0d,0x0a,0x20,0x20,0x3c,
0x6d,0x65,0x74,0x61,0x20,0x68,0x74,0x74,0x70,0x2d,0x65,0x71,0x75,0x69,0x76,0x3d,
0x22,0x43,0x6f,0x6e,0x74,0x65,0x6e,0x74,0x2d,0x54,0x79,0x70,0x65,0x22,0x0d,0x0a,
0x20,0x63,0x6f,0x6e,0x74,0x65,0x6e,0x74,0x3d,0x22,0x74,0x65,0x78,0x74,0x2f,0x68,
0x74,0x6d,0x6c,0x3b,0x20,0x63,0x68,0x61,0x72,0x73,0x65,0x74,0x3d,0x77,0x69,0x6e,
0x64,0x6f,0x77,0x73,0x2d,0x31,0x32,0x35,0x32,0x22,0x3e,0x0d,0x0a,0x20,0x20,0x3c,
0x6d,0x65,0x74,0x61,0x20,0x68,0x74,0x74,0x70,0x2d,0x65,0x71,0x75,0x69,0x76,0x3d,
0x22,0x72,0x65,0x66,0x72,0x65,0x73,0x68,0x22,0x20,0x63,0x6f,0x6e,0x74,0x65,0x6e,
0x74,0x3d,0x22,0x31,0x22,0x3e,0x0d,0x0a,0x20,0x20,0x3c,0x6d,0x65,0x74,0x61,0x20,
0x63,0x6f,0x6e,0x74,0x65,0x6e,0x74,0x3d,0x22,0x4d,0x53,0x48,0x54,0x4d,0x4c,0x20,
0x36,0x2e,0x30,0x30,0x2e,0x32,0x38,0x30,0x30,0x2e,0x31,0x35,0x36,0x31,0x22,0x20,
0x6e,0x61,0x6d,0x65,0x3d,0x22,0x47,0x45,0x4e,0x45,0x52,0x41,0x54,0x4f,0x52,0x22,
0x3e,0x0d,0x0a,0x20,0x20,0x3c,0x73,0x74,0x79,0x6c,0x65,0x20,0x3d,0x22,0x66,0x6f,
0x6e,0x74,0x2d,0x77,0x65,0x69,0x67,0x68,0x74,0x3a,0x20,0x6e,0x6f,0x72,0x6d,0x61,
0x6c,0x3b,0x20,0x66,0x6f,0x6e,0x74,0x2d,0x66,0x61,0x6d,0x69,0x6c,0x79,0x3a,0x20,
0x56,0x65,0x72,0x64,0x61,0x6e,0x61,0x3b,0x22,0x3e,0x3c,0x2f,0x73,0x74,0x79,0x6c,
0x65,0x3e,0x0d,0x0a,0x3c,0x2f,0x68,0x65,0x61,0x64,0x3e,0x0d,0x0a,0x3c,0x62,0x6f,
0x64,0x79,0x3e,0x0d,0x0a,0x3c,0x68,0x34,0x3e,0x3c,0x73,0x6d,0x61,0x6c,0x6c,0x20,
0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,0x66,0x6f,0x6e,0x74,0x2d,0x66,0x61,0x6d,0x69,
0x6c,0x79,0x3a,0x20,0x56,0x65,0x72,0x64,0x61,0x6e,0x61,0x3b,0x22,0x3e,0x3c,0x73,
0x6d,0x61,0x6c,0x6c,0x3e,0x3c,0x62,0x69,0x67,0x3e,0x3c,0x62,0x69,0x67,0x3e,0x3c,
0x62,0x69,0x67,0x0d,0x0a,0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,0x66,0x6f,0x6e,
0x74,0x2d,0x77,0x65,0x69,0x67,0x68,0x74,0x3a,0x20,0x62,0x6f,0x6c,0x64,0x3b,0x22,
0x3e,0x3c,0x62,0x69,0x67,0x3e,0x3c,0x73,0x74,0x72,0x6f,0x6e,0x67,0x3e,0x3c,0x65,
0x6d,0x3e,0x3c,0x73,0x70,0x61,0x6e,0x0d,0x0a,0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,
0x22,0x66,0x6f,0x6e,0x74,0x2d,0x73,0x74,0x79,0x6c,0x65,0x3a,0x20,0x69,0x74,0x61,
0x6c,0x69,0x63,0x3b,0x22,0x3e,0x53,0x54,0x4d,0x33,0x32,0x46,0x34,0x78,0x78,0x20,
0x4c,0x69,0x73,0x74,0x20,0x6f,0x66,0x20,0x74,0x61,0x73,0x6b,0x73,0x20,0x61,0x6e,
0x64,0x0d,0x0a,0x74,0x68,0x65,0x69,0x72,0x20,0x73,0x74,0x61,0x74,0x75,0x73,0x3c,
0x2f,0x73,0x70,0x61,0x6e,0x3e,0x3c,0x2f,0x65,0x6d,0x3e,0x3c,0x2f,0x73,0x74,0x72,
0x6f,0x6e,0x67,0x3e,0x3c,0x2f,0x62,0x69,0x67,0x3e,0x3c,0x2f,0x62,0x69,0x67,0x3e,
0x3c,0x2f,0x62,0x69,0x67,0x3e,0x3c,0x2f,0x62,0x69,0x67,0x3e,0x3c,0x2f,0x73,0x6d,
0x61,0x6c,0x6c,0x3e,0x3c,0x2f,0x73,0x6d,0x61,0x6c,0x6c,0x3e,0x3c,0x2f,0x68,0x34,
0x3e,0x0d,0x0a,0x3c,0x68,0x72,0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,0x77,0x69,
0x64,0x74,0x68,0x3a,0x20,0x31,0x30,0x30,0x25,0x3b,0x20,0x68,0x65,0x69,0x67,0x68,
0x74,0x3a,0x20,0x32,0x70,0x78,0x3b,0x22,0x3e,0x3c,0x73,0x70,0x61,0x6e,0x0d,0x0a,
0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,0x66,0x6f,0x6e,0x74,0x2d,0x77,0x65,0x69,
0x67,0x68,0x74,0x3a,0x20,0x62,0x6f,0x6c,0x64,0x3b,0x22,0x3e,0x0d,0x0a,0x3c,0x2f,
0x73,0x70,0x61,0x6e,0x3e,0x3c,0x73,0x70,0x61,0x6e,0x20,0x73,0x74,0x79,0x6c,0x65,
0x3d,0x22,0x66,0x6f,0x6e,0x74,0x2d,0x77,0x65,0x69,0x67,0x68,0x74,0x3a,0x20,0x62,
0x6f,0x6c,0x64,0x3b,0x22,0x3e,0x0d,0x0a,0x3c,0x74,0x61,0x62,0x6c,0x65,0x20,0x73,
0x74,0x79,0x6c,0x65,0x3d,0x22,0x77,0x69,0x64,0x74,0x68,0x3a,0x20,0x39,0x36,0x31,
0x70,0x78,0x3b,0x20,0x68,0x65,0x69,0x67,0x68,0x74,0x3a,0x20,0x33,0x30,0x70,0x78,
0x3b,0x22,0x20,0x62,0x6f,0x72,0x64,0x65,0x72,0x3d,0x22,0x31,0x22,0x0d,0x0a,0x20,
0x63,0x65,0x6c,0x6c,0x70,0x61,0x64,0x64,0x69,0x6e,0x67,0x3d,0x22,0x32,0x22,0x20,
0x63,0x65,0x6c,0x6c,0x73,0x70,0x61,0x63,0x69,0x6e,0x67,0x3d,0x22,0x32,0x22,0x3e,
0x0d,0x0a,0x20,0x20,0x3c,0x74,0x62,0x6f,0x64,0x79,0x3e,0x0d,0x0a,0x20,0x20,0x20,
0x20,0x3c,0x74,0x72,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x3c,0x74,0x64,
0x0d,0x0a,0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,0x66,0x6f,0x6e,0x74,0x2d,0x66,
0x61,0x6d,0x69,0x6c,0x79,0x3a,0x20,0x56,0x65,0x72,0x64,0x61,0x6e,0x61,0x3b,0x20,
0x66,0x6f,0x6e,0x74,0x2d,0x77,0x65,0x69,0x67,0x68,0x74,0x3a,0x20,0x62,0x6f,0x6c,
0x64,0x3b,0x20,0x66,0x6f,0x6e,0x74,0x2d,0x73,0x74,0x79,0x6c,0x65,0x3a,0x20,0x69,
0x74,0x61,0x6c,0x69,0x63,0x3b,0x20,0x62,0x61,0x63,0x6b,0x67,0x72,0x6f,0x75,0x6e,
0x64,0x2d,0x63,0x6f,0x6c,0x6f,0x72,0x3a,0x20,0x72,0x67,0x62,0x28,0x35,0x31,0x2c,
0x20,0x35,0x31,0x2c,0x20,0x32,0x35,0x35,0x29,0x3b,0x20,0x74,0x65,0x78,0x74,0x2d,
0x61,0x6c,0x69,0x67,0x6e,0x3a,0x20,0x63,0x65,0x6e,0x74,0x65,0x72,0x3b,0x22,0x3e,
0x3c,0x73,0x6d,0x61,0x6c,0x6c,0x3e,0x3c,0x61,0x0d,0x0a,0x20,0x68,0x72,0x65,0x66,
0x3d,0x22,0x2f,0x53,0x54,0x4d,0x33,0x32,0x46,0x34,0x78,0x78,0x2e,0x68,0x74,0x6d,
0x6c,0x22,0x3e,0x3c,0x73,0x70,0x61,0x6e,0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,
0x63,0x6f,0x6c,0x6f,0x72,0x3a,0x20,0x77,0x68,0x69,0x74,0x65,0x3b,0x22,0x3e,0x48,
0x6f,0x6d,0x65,0x0d,0x0a,0x70,0x61,0x67,0x65,0x3c,0x2f,0x73,0x70,0x61,0x6e,0x3e,
0x3c,0x2f,0x61,0x3e,0x3c,0x2f,0x73,0x6d,0x61,0x6c,0x6c,0x3e,0x3c,0x2f,0x74,0x64,
0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x3c,0x74,0x64,0x0d,0x0a,0x20,0x73,
0x74,0x79,0x6c,0x65,0x3d,0x22,0x66,0x6f,0x6e,0x74,0x2d,0x66,0x61,0x6d,0x69,0x6c,
0x79,0x3a,0x20,0x56,0x65,0x72,0x64,0x61,0x6e,0x61,0x3b,0x20,0x66,0x6f,0x6e,0x74,
0x2d,0x77,0x65,0x69,0x67,0x68,0x74,0x3a,0x20,0x62,0x6f,0x6c,0x64,0x3b,0x20,0x66,
0x6f,0x6e,0x74,0x2d,0x73,0x74,0x79,0x6c,0x65,0x3a,0x20,0x69,0x74,0x61,0x6c,0x69,
0x63,0x3b,0x20,0x62,0x61,0x63,0x6b,0x67,0x72,0x6f,0x75,0x6e,0x64,0x2d,0x63,0x6f,
0x6c,0x6f,0x72,0x3a,0x20,0x72,0x67,0x62,0x28,0x35,0x31,0x2c,0x20,0x35,0x31,0x2c,
0x20,0x32,0x35,0x35,0x29,0x3b,0x20,0x74,0x65,0x78,0x74,0x2d,0x61,0x6c,0x69,0x67,
0x6e,0x3a,0x20,0x63,0x65,0x6e,0x74,0x65,0x72,0x3b,0x22,0x3e,0x3c,0x61,0x0d,0x0a,
0x20,0x68,0x72,0x65,0x66,0x3d,0x22,0x53,0x54,0x4d,0x33,0x32,0x46,0x34,0x78,0x78,
0x41,0x44,0x43,0x2e,0x68,0x74,0x6d,0x6c,0x22,0x3e,0x3c,0x73,0x70,0x61,0x6e,0x20,
0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,0x66,0x6f,0x6e,0x74,0x2d,0x77,0x65,0x69,0x67,
0x68,0x74,0x3a,0x20,0x62,0x6f,0x6c,0x64,0x3b,0x22,0x3e,0x3c,0x2f,0x73,0x70,0x61,
0x6e,0x3e,0x3c,0x2f,0x61,0x3e,0x3c,0x73,0x6d,0x61,0x6c,0x6c,0x3e,0x3c,0x61,0x0d,
0x0a,0x20,0x68,0x72,0x65,0x66,0x3d,0x22,0x2f,0x53,0x54,0x4d,0x33,0x32,0x46,0x34,
0x78,0x78,0x54,0x41,0x53,0x4b,0x53,0x2e,0x68,0x74,0x6d,0x6c,0x22,0x3e,0x3c,0x73,
0x70,0x61,0x6e,0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,0x63,0x6f,0x6c,0x6f,0x72,
0x3a,0x20,0x77,0x68,0x69,0x74,0x65,0x3b,0x22,0x3e,0x4c,0x69,0x73,0x74,0x0d,0x0a,
0x6f,0x66,0x20,0x74,0x61,0x73,0x6b,0x73,0x3c,0x2f,0x73,0x70,0x61,0x6e,0x3e,0x3c,
0x2f,0x61,0x3e,0x3c,0x2f,0x73,0x6d,0x61,0x6c,0x6c,0x3e,0x3c,0x2f,0x74,0x64,0x3e,
0x0d,0x0a,0x20,0x20,0x20,0x20,0x3c,0x2f,0x74,0x72,0x3e,0x0d,0x0a,0x20,0x20,0x3c,
0x2f,0x74,0x62,0x6f,0x64,0x79,0x3e,0x0d,0x0a,0x3c,0x2f,0x74,0x61,0x62,0x6c,0x65,
0x3e,0x0d,0x0a,0x3c,0x62,0x72,0x3e,0x0d,0x0a,0x3c,0x2f,0x73,0x70,0x61,0x6e,0x3e,
0x3c,0x73,0x70,0x61,0x6e,0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,0x66,0x6f,0x6e,
0x74,0x2d,0x77,0x65,0x69,0x67,0x68,0x74,0x3a,0x20,0x62,0x6f,0x6c,0x64,0x3b,0x22,
0x3e,0x3c,0x2f,0x73,0x70,0x61,0x6e,0x3e,0x3c,0x73,0x6d,0x61,0x6c,0x6c,0x3e,0x3c,
0x73,0x70,0x61,0x6e,0x0d,0x0a,0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,0x66,0x6f,
0x6e,0x74,0x2d,0x66,0x61,0x6d,0x69,0x6c,0x79,0x3a,0x20,0x56,0x65,0x72,0x64,0x61,
0x6e,0x61,0x3b,0x22,0x3e,0x4e,0x75,0x6d,0x62,0x65,0x72,0x20,0x6f,0x66,0x20,0x70,
0x61,0x67,0x65,0x20,0x68,0x69,0x74,0x73,0x3a,0x0d,0x0a,0x00};

/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/

/**
  * @brief serve tcp connection  
  * @param conn: connection socket 
  * @retval None
  */
void http_server_serve(int conn) 
{
    int buflen = 1500;
    int ret;
    struct fs_file file;
    unsigned char recv_buffer[1500];
                    
    /* Read in the request */
    ret = read(conn, recv_buffer, buflen); 

    if(ret < 0) return;

    if( recv_buffer[0] == 'G' &&
        recv_buffer[1] == 'E' &&
        recv_buffer[2] == 'T' &&
        recv_buffer[3] == ' ' &&
        recv_buffer[4] == '/'
    )
    {
            /* 发送数据头 */
            write(conn, http_html_hdr, sizeof(http_html_hdr) - 1);

            /* 发送网页数据 */
            write(conn, http_index_html,sizeof(http_index_html) - 1);
    }

//   /* Check if request to get ST.gif */
//   if (strncmp((char *)recv_buffer,"GET /STM32F4xx_files/ST.gif",27)==0)
//   {
//     fs_open(&file, "/STM32F4xx_files/ST.gif"); 
//     write(conn, (const unsigned char*)(file.data), (size_t)file.len);
//     fs_close(&file);
//   }
//   /* Check if request to get stm32.jpeg */
//   else if (strncmp((char *)recv_buffer,"GET /STM32F4xx_files/stm32.jpg",30)==0)
//   {
//     fs_open(&file, "/STM32F4xx_files/stm32.jpg"); 
//     write(conn, (const unsigned char*)(file.data), (size_t)file.len);
//     fs_close(&file);
//   }
//   /* Check if request to get ST logo.jpeg */
//   else if (strncmp((char *)recv_buffer,"GET /STM32F4xx_files/logo.jpg", 29) == 0)
//   {
//     fs_open(&file, "/STM32F4xx_files/logo.jpg"); 
//     write(conn, (const unsigned char*)(file.data), (size_t)file.len);
//     fs_close(&file);
//   }
//   else if(strncmp((char *)recv_buffer, "GET /STM32F4xxTASKS.html", 24) == 0)
//   {
//     /* Load dynamic page */
//     DynWebPage(conn);
//   }
//   else if((strncmp((char *)recv_buffer, "GET /STM32F4xx.html", 19) == 0)||(strncmp((char *)recv_buffer, "GET / ", 6) == 0))
//   {
//     /* Load STM32F4xx */
//     fs_open(&file, "/STM32F4xx.html"); 
//     write(conn, (const unsigned char*)(file.data), (size_t)file.len);
//     fs_close(&file);
//   }
//   else
//   {
//     /* Load 404 page */
//     fs_open(&file, "/404.html");
//     write(conn, (const unsigned char*)(file.data), (size_t)file.len);
//     fs_close(&file);
//   }
  /* Close connection socket */
  close(conn);
}

/**
  * @brief  http server thread 
  * @param arg: pointer on argument(not used here) 
  * @retval None
  */
static void http_server_socket_thread(void *arg)
{
  int sock, newconn, size;
  struct sockaddr_in address, remotehost;

 /* create a TCP socket */
  if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) 
  {
    return;
  }
  
  /* bind to port 80 at any interface */
  address.sin_family = AF_INET;
  address.sin_port = htons(80);
  address.sin_addr.s_addr = INADDR_ANY;

  if (bind(sock, (struct sockaddr *)&address, sizeof (address)) < 0)
  {
    return;
  }
  
  /* listen for incoming connections (TCP listen backlog = 5) */
  listen(sock, 5);
  
  size = sizeof(remotehost);
  
  while (1) 
  {
    newconn = accept(sock, (struct sockaddr *)&remotehost, (socklen_t *)&size);
    http_server_serve(newconn);
  }
}

/**
  * @brief  Initialize the HTTP server (start its thread) 
  * @param  none
  * @retval None
  */
void http_server_socket_init()
{
  sys_thread_new("HTTP", http_server_socket_thread, NULL, DEFAULT_THREAD_STACKSIZE * 2, 4);
}

/**
  * @brief  Create and send a dynamic Web Page. This page contains the list of 
  *         running tasks and the number of page hits. 
  * @param  conn connection socket
  * @retval None
  */
void DynWebPage(int conn)
{
  portCHAR pagehits[10];

  memset(PAGE_BODY, 0,512);

  /* Update the hit count */
  nPageHits++;
  sprintf( pagehits, "%d", (int)nPageHits );
  strcat(PAGE_BODY, pagehits);
  strcat((char *) PAGE_BODY, "<pre><br>Name          State  Priority  Stack   Num" );
  strcat((char *) PAGE_BODY, "<br>---------------------------------------------<br>"); 
    
  /* The list of tasks and their status */
  //osThreadList((unsigned char *)(PAGE_BODY + strlen(PAGE_BODY)));
  strcat((char *) PAGE_BODY, "<br><br>---------------------------------------------"); 
  strcat((char *) PAGE_BODY, "<br>B : Blocked, R : Ready, D : Deleted, S : Suspended<br>");
  
  /* Send the dynamically generated page */
  write(conn, PAGE_START, strlen((char*)PAGE_START));
  write(conn, PAGE_BODY, strlen(PAGE_BODY));
}















