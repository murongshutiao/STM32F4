#include "./Sensor/mpu6050/bsp_i2c_mpu6050.h"

  
I2C_HandleTypeDef I2C_Handle;					
/*******************************  Function ************************************/


#define MPU_ERROR 		I2C_ERROR
#define MPU_INFO 		I2C_INFO



/**
  * @brief  初始化I2C总线，使用I2C前需要调用
  * @param  无
  * @retval 无
  */
void MPU6050_I2C_Init(void) 
{
	GPIO_InitTypeDef GPIO_InitStructure;

	MPU6050_I2C_RCC_CLK_ENABLE();
	MPU6050_I2C_SCL_GPIO_CLK_ENABLE();
	MPU6050_I2C_SDA_GPIO_CLK_ENABLE();

	/* 配置I2Cx引脚: SCL ----------------------------------------*/
	GPIO_InitStructure.Pin =  MPU6050_I2C_SCL_GPIO_PIN; 
	GPIO_InitStructure.Mode = GPIO_MODE_AF_OD;
	GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
	GPIO_InitStructure.Pull= GPIO_NOPULL;
	GPIO_InitStructure.Alternate=MPU6050_I2C_AF; 
	HAL_GPIO_Init(MPU6050_I2C_SCL_GPIO_PORT, &GPIO_InitStructure);

	/* 配置I2Cx引脚: SDA ----------------------------------------*/
	GPIO_InitStructure.Pin = MPU6050_I2C_SDA_GPIO_PIN;  
	HAL_GPIO_Init(MPU6050_I2C_SDA_GPIO_PORT, &GPIO_InitStructure); 
	
	if(HAL_I2C_GetState(&I2C_Handle) == HAL_I2C_STATE_RESET)
	{	
		/* 强制复位I2C外设时钟 */  
		MPU6050_I2C_FORCE_RESET(); 

		/* 释放I2C外设时钟复位 */  
		MPU6050_I2C_RELEASE_RESET(); 
		
		/* I2C 配置 */
		I2C_Handle.Instance = MPU6050_I2C;
		I2C_Handle.Init.AddressingMode  = I2C_ADDRESSINGMODE_7BIT;
		I2C_Handle.Init.ClockSpeed      = 400000;
		I2C_Handle.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
		I2C_Handle.Init.DutyCycle       = I2C_DUTYCYCLE_2;
		I2C_Handle.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
		I2C_Handle.Init.NoStretchMode   = I2C_NOSTRETCH_DISABLE;
		I2C_Handle.Init.OwnAddress1     = 0;
		I2C_Handle.Init.OwnAddress2     = 0;     

		HAL_I2C_Init(&I2C_Handle);	
		/* 使能模拟滤波器 */
		HAL_I2CEx_AnalogFilter_Config(&I2C_Handle, I2C_ANALOGFILTER_ENABLE); 
	}
}



/**
  * @brief  Manages error callback by re-initializing I2C.
  * @param  Addr: I2C Address
  * @retval None
  */
static void I2Cx_Error(uint8_t Addr)
{
	/* 恢复I2C寄存器为默认值 */
	HAL_I2C_DeInit(&I2C_Handle); 
	/* 重新初始化I2C外设 */
	MPU6050_I2C_Init();
}



/**
  * @brief  写寄存器，这是提供给上层的接口
  * @param  slave_addr: 从机地址
  * @param 	reg_addr:寄存器地址
  * @param  len：写入的长度
  * @param  data_ptr:指向要写入的数据
  * @retval 正常为0，不正常为非0
  */
int MPU6050_I2C_WriteRegister(unsigned char slave_addr,
                                        unsigned char reg_addr,
                                        unsigned short len, 
                                        unsigned char *data_ptr)
{
	HAL_StatusTypeDef status = HAL_OK;

	status = HAL_I2C_Mem_Write(&I2C_Handle, slave_addr, reg_addr, I2C_MEMADD_SIZE_8BIT,data_ptr, len,I2Cx_FLAG_TIMEOUT); 

	/* 检查通讯状态 */
	if(status != HAL_OK)
	{
		/* 总线出错处理 */
		I2Cx_Error(slave_addr);
	}

	while (HAL_I2C_GetState(&I2C_Handle) != HAL_I2C_STATE_READY)
	{
		
	}

	/* 检查SENSOR是否就绪进行下一次读写操作 */
	while (HAL_I2C_IsDeviceReady(&I2C_Handle, slave_addr, I2Cx_FLAG_TIMEOUT, I2Cx_FLAG_TIMEOUT) == HAL_TIMEOUT);

	/* 等待传输结束 */
	while (HAL_I2C_GetState(&I2C_Handle) != HAL_I2C_STATE_READY)
	{
		
	}
	return status;
}



/**
  * @brief  读寄存器，这是提供给上层的接口
	* @param  slave_addr: 从机地址
	* @param 	reg_addr:寄存器地址
	* @param len：要读取的长度
	*	@param data_ptr:指向要存储数据的指针
  * @retval 正常为0，不正常为非0
  */
int MPU6050_I2C_ReadRegister(unsigned char slave_addr,
                                       unsigned char reg_addr,
                                       unsigned short len, 
                                       unsigned char *data_ptr)
{
	HAL_StatusTypeDef status = HAL_OK;
	status =HAL_I2C_Mem_Read(&I2C_Handle,slave_addr,reg_addr,I2C_MEMADD_SIZE_8BIT,data_ptr,len,I2Cx_FLAG_TIMEOUT);    
	/* 检查通讯状态 */
	if(status != HAL_OK)
	{
		/* 总线出错处理 */
		I2Cx_Error(slave_addr);
	}
	while (HAL_I2C_GetState(&I2C_Handle) != HAL_I2C_STATE_READY)
	{
		
	}
	/* 检查SENSOR是否就绪进行下一次读写操作 */
	while (HAL_I2C_IsDeviceReady(&I2C_Handle, slave_addr, I2Cx_FLAG_TIMEOUT, I2Cx_FLAG_TIMEOUT) == HAL_TIMEOUT);
	/* 等待传输结束 */
	while (HAL_I2C_GetState(&I2C_Handle) != HAL_I2C_STATE_READY)
	{
		
	}
	return status;
}



/**
  * @brief   写数据到MPU6050寄存器
  * @param   reg_add:寄存器地址
	* @param	 reg_data:要写入的数据
  * @retval  
  */
void MPU6050_WriteReg(uint8_t reg_add,uint8_t reg_dat)
{
	MPU6050_I2C_WriteRegister(MPU6050_ADDRESS,reg_add,1,&reg_dat);
}

/**
  * @brief   从MPU6050寄存器读取数据
  * @param   reg_add:寄存器地址
	* @param	 Read：存储数据的缓冲区
	* @param	 num：要读取的数据量
  * @retval  
  */
void MPU6050_ReadData(uint8_t reg_add,unsigned char* Read,uint8_t num)
{
	MPU6050_I2C_ReadRegister(MPU6050_ADDRESS,reg_add,num,Read);
}


/**
  * @brief   初始化MPU6050芯片
  * @param   
  * @retval  
  */
void MPU6050_Init(void)
{
	MPU6050_I2C_Init();

	//在初始化之前要延时一段时间，若没有延时，则断电后再上电数据可能会出错
	Delay(100);
	MPU6050_WriteReg(MPU6050_RA_PWR_MGMT_1, 0x00);	     //解除休眠状态
	MPU6050_WriteReg(MPU6050_RA_SMPLRT_DIV , 0x07);	    //陀螺仪采样率
	MPU6050_WriteReg(MPU6050_RA_CONFIG , 0x06);	
	MPU6050_WriteReg(MPU6050_RA_ACCEL_CONFIG , 0x01);	  //配置加速度传感器工作在16G模式
	MPU6050_WriteReg(MPU6050_RA_GYRO_CONFIG, 0x18);     //陀螺仪自检及测量范围，典型值：0x18(不自检，2000deg/s)
	Delay(200);
}

/**
  * @brief   读取MPU6050的ID
  * @param   
  * @retval  正常返回1，异常返回0
  */
uint8_t MPU6050ReadID(void)
{
	unsigned char Re = 0;
    MPU6050_ReadData(MPU6050_RA_WHO_AM_I,&Re,1);    //读器件地址
	if(Re != 0x68)
	{
		MPU_ERROR("MPU6050 dectected error!\r\n检测不到MPU6050模块，请检查模块与开发板的接线");
		return 0;
	}
	else
	{
		MPU_INFO("MPU6050 ID = %d\r\n",Re);
		return 1;
	}
		
}



/**
  * @brief   读取MPU6050的加速度数据
  * @param   
  * @retval  
  */
void MPU6050ReadAcc(short *accData)
{
    uint8_t buf[6];
    MPU6050_ReadData(MPU6050_ACC_OUT, buf, 6);
    accData[0] = (buf[0] << 8) | buf[1];	/* X */
    accData[1] = (buf[2] << 8) | buf[3];	/* Y */
    accData[2] = (buf[4] << 8) | buf[5];	/* Z */
}



/**
  * @brief   读取MPU6050的角加速度数据
  * @param   
  * @retval  
  */
void MPU6050ReadGyro(short *gyroData)
{
    uint8_t buf[6];
    MPU6050_ReadData(MPU6050_GYRO_OUT,buf,6);
    gyroData[0] = (buf[0] << 8) | buf[1];	/* X */
    gyroData[1] = (buf[2] << 8) | buf[3];	/* Y */
    gyroData[2] = (buf[4] << 8) | buf[5];	/* Z */
}



/**
  * @brief   读取MPU6050的原始温度数据
  * @param   
  * @retval  
  */
void MPU6050ReadTemp(short *tempData)
{
	uint8_t buf[2];
    MPU6050_ReadData(MPU6050_RA_TEMP_OUT_H,buf,2);     //读取温度值
    *tempData = (buf[0] << 8) | buf[1];
}

/**
  * @brief   读取MPU6050的温度数据，转化成摄氏度
  * @param   
  * @retval  
  */
void MPU6050_ReturnTemp(float *Temperature)
{
	short temp3;
	uint8_t buf[2];
	
	MPU6050_ReadData(MPU6050_RA_TEMP_OUT_H,buf,2);     //读取温度值
    temp3= (buf[0] << 8) | buf[1];	
	*Temperature=((double) temp3/340.0)+36.53;

}



void MPU6050_Test_CallBack(void)
{
	short Acel[3];	/* 加速度 */
	short Gyro[3];	/* 角加速度 */
	float Temp;		/* 温度 */

	MPU6050ReadAcc(Acel);
	MPU6050ReadGyro(Gyro);
	MPU6050_ReturnTemp(&Temp);

}

void MPU6050_Test(void)
{

	if(MPU6050ReadID() == 1)
	{
		/* 启动定时器 */
		LED_RED;
		multi_timer_start(&Timer_MPU6050_Handler,5000,Timer_MPU6050_CallBack,&MPU6050_Test_CallBack);
	}
	else
	{
		LED_GREEN;
	}


}




